#!/bin/bash
# author: yin-jianhong@163.com
# version: v0.2
# dependency: systemd-nspawn
# used to create light container/ns for nfs/cifs test on RHEL/CentOS 7 or later

LANG=C
NSHome=/opt/NS
AT=("$@")

switchroot() {
	[[ $(id -u) != 0 ]] && {
		echo -e "{Warn} $0 need root permission, try:\n  sudo $0 ${AT[@]}" | grep --color=always . >&2
		exec sudo $0 "${AT[@]}"
	}
}

Usage() {
	cat <<-EOF
	Usage:
	  $0 <-n nsname> [options] [exec -- cmdline | ps | del | install pkgs | {jj|jinja} pkgs ]
	  $0 ls

	Options:
	  -h, --help           ; show this help info
	  -n {nsname}          ; ns(name space) name
	  -p {pkgs}            ; packages you want in ns(name space)
	  -d                   ; debug mode
	  -v                   ; verbose mode, output more info
	  --veth-ip {ip1,ip2}  ; ip address pair for veth pair; ip1 for host side and ip2 for ns side
	  --macvlan-ip {ip1[,ip2...]} ; ip address[es] for ns macvlan if[s]; all for ns side
	  --bind {src[:dst]}   ; see systemd-nspawn --bind
	  --robind {src[:dst]} ; see systemd-nspawn --bind-ro
	  --vol, --volatile {yes|no}  ; see systemd-nspawn --volatile. default is no
	  --clone {ns}         ; clone from ns
	  --noboot             ; no boot
	  -x                   ; see systemd-nspawn -x, need btrfs as rootfs

	Examples create ns by using mini fs tree + host /usr:
	  # same as example ns1, but use a it's own fs tree instead reuse host os tree
	  #  so you can do anything in this ns, and don't worry about any impact on the host
	  $0 jj nsmini bash   # create a mini rootfs template
	  $0 -n ns0 --veth-ip 192.168.0.1,192.168.0.2 --noboot -robind=/usr --clone nsmini
	  $0 -n ns1 --veth-ip 192.168.1.1,192.168.1.2 --macvlan-ip 192.168.254.11 -bind=/usr --clone nsmini

	Examples create ns by using absolute own fs tree:
	  $0 jj nsbase iproute iputils nfs-utils firewalld   # create a base rootfs template
	  $0 -n ns2 --veth-ip 192.168.2.1,192.168.2.2 --macvlan-ip 192.168.254.12,192.168.253.12 --clone nsbase
	  $0 -n ns3 --veth-ip 192.168.3.1,192.168.3.2 --macvlan-ip 192.168.254.13,192.168.253.13 --clone nsbase

	Examples sub-command:
	  $0 ls                                # list all ns
	  $0 ps ns2                            # show ps tree of ns2
	  $0 del ns2                           # delete/remove ns2 but keep rootdir
	  $0 delete ns2                        # delete/remove ns2 and it's rootdir
	  $0 install ns2 cifs-utils            # install cifs-utils in ns2

	  $0 exec ns2 ip addr show             # exec command in ns2
	  $0 exec ns2 -- ls -l /               # exec command in ns2

	  systemctl start nfs-server
	  exportfs -o ro,no_root_squash "*:/usr/share"
	  $0 exec ns2 -- mkdir -p /mnt/nfs              # exec command in ns2
	  $0 exec ns2 -- showmount -e 192.168.2.1       # exec command in ns2
	  $0 exec ns2 -- mount 192.168.2.1:/ /mnt/nfs   # exec command in ns2
	  $0 exec ns2 -- showmount -e 192.168.254.254     # exec command in ns2
	  $0 exec ns2 -- mount 192.168.254.254:/ /mnt/nfs # exec command in ns2

	EOF
}

is_valid_ip() {
    local  ip=$1
    local  stat=1

    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        ip=(${ip//./ })
        [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 \
            && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
        stat=$?
    fi
    return $stat
}

ns_init_pid() {
	local nsdir=$1
	local ppid initpid

	ppid=$(pgrep -f "^systemd-nspawn .*(-D $nsdir|-M ${nsdir##*/})$") || return 1
	initpid=$(pgrep -f ^/usr/lib/systemd/systemd -P "$ppid") || {
		initpid=$(pgrep -f ^-bash -P "$ppid") || {
			return 1
		}
	}
	echo $initpid
}

ns_pstree() {
	local ns=$1
	local nsdir=$NSHome/$ns
	local tree=$(ps axf | sed -rn -e 's/^(( *[^ ]+){4} )(.*)$/\3 # \1/' -e "/^( ._ )?systemd-nspawn .*(${nsdir//\//\\/}|-M $ns)/,/^( ._ )?[^ ]/p" | sed -r '${/^( ._ )?[^ ]/d}')
	[[ "$tree" = ' \_ '* ]] && {
		tree=$(sed 's/^....//' <<<"$tree")
	}
	echo "$tree"
}

_nsexec() {
	local initpid=$1
	shift
	nsenter --target "$initpid" --mount --uts --ipc --net --pid -- bash -c "$*"
}

nsexec() {
	local ns=$1
	local nsdir=$NSHome/$ns
	shift
	local initpid=$(ns_init_pid $nsdir)
	[[ "$nsverbose" = yes ]] && echo "[NS:$ns] # $@" | GREP_COLORS='ms=01;36' grep --color .
	_nsexec "$initpid" "$@"
}

getDefaultNic() {
	ip route | awk '/default/{match($0,"dev ([^ ]+)",M); print M[1]; exit}'
}

chroot_install() {
	local releasever
	local rootfs=$1; shift

	if which dnf &>/dev/null; then
		releasever=$(rpm -q --qf "%{version}" -f /etc/os-release)
		read repo < <(LANG=C dnf whatprovides bash|awk '$1 == "Repo" && $3 != "@System" {print $3}')
		dnf --setopt=strict=0 --disablerepo=* --enablerepo=$repo --nogpg --installroot=$rootfs --releasever=$releasever install -y "$@"
		dnf -y --nogpg --installroot=$rootfs clean all 2>/dev/null
		rm -rf $rootfs/var/cache/dnf/*
	else
		read repo < <(LANG=C yum whatprovides bash|awk '$1 == "Repo" && $3 != "installed" {print $3}')
		yum --setopt=strict=0 --disablerepo=* --enablerepo=$repo --nogpg --installroot=$rootfs install -y "$@"
		yum -y --nogpg --installroot=$rootfs clean all 2>/dev/null
		rm -rf $rootfs/var/cache/yum/*
	fi
}

nsjinja() {
	local ns=$1
	local rootdir=$NSHome/$ns
	shift
	chroot_install $rootdir "$@"
}

BOOT_OPT=-b
NET_MACVLAN_OPTS=
BIND_OPTS=
VOLATILE_OPT=
MachineOpt=
NS_VETH_IP=
NS_MACVLAN_IPS=
HOST_VETH_IP=
InitPid=
INIT_PKG=systemd

# command line parse
_at=`getopt -o hn:p:dxv \
	--long help \
	--long veth-ip: \
	--long macvlan-ip: \
	--long bind: \
	--long robind: \
	--long volatile: --long vol: \
	--long clone: \
	--long noboot \
    -a -n "$0" -- "$@"`
eval set -- "$_at"
while true; do
	case "$1" in
	-h|--help) Usage; shift 1; exit 0;;
	-n) NS="$2"; shift 2;;
	-p) PKGS+="$2"; shift 2;;
	-d) DEBUG=yes; shift 1;;
	-v) nsverbose=yes; shift 1;;
	--veth-ip) read HOST_VETH_IP NS_VETH_IP <<<"${2//,/ }"; shift 2;;
	--macvlan-ip) NS_MACVLAN_IPS="${2//,/ }"; shift 2;;
	--bind) BIND_OPTS+="--bind=$2 "; shift 2;;
	--robind) BIND_OPTS+="--bind-ro=$2 "; shift 2;;
	--volatile|--vol) VOLATILE_OPT="--volatile=$2"; shift 2;;
	--clone) CLONE=$2; shift 2;;
	-x) SHARE_SYSTEM=yes; shift 1;;
	--noboot) BOOT_OPT=; INIT_PKG="bash"; shift 1;;
	--) shift; break;;
	esac
done

# __prepare__
which tmux &>/dev/null || dep+=\ tmux
which firewall-cmd &>/dev/null || dep+=\ firewalld
which rsync &>/dev/null || dep+=\ rsync
which systemd-nspawn &>/dev/null || dep+=\ systemd-container
[[ -n "$dep" ]] && {
	echo -e "{Info} install dependences ..."
	sudo yum install -y $dep >&2
}

# __main__
subcmd=$1
case $subcmd in
jj|jinja) switchroot; shift
	[[ -z "$NS" ]] && { NS=$1; shift; }
	[[ -z "$NS" ]] && { Usage >&2; exit 1; }
	nsjinja $NS "$@"
	exit $?;;
exec|exe|ex|e) switchroot; shift
	[[ -z "$NS" ]] && { NS=$1; shift; }
	[[ -z "$NS" ]] && { Usage >&2; exit 1; }
	nsexec $NS "$@"
	exit $?;;
install|ins*) switchroot; shift
	[[ -z "$NS" ]] && { NS=$1; shift; }
	[[ -z "$NS" ]] && { Usage >&2; exit 1; }
	NSdir=$NSHome/$NS
	chroot_install $NSdir "$@"
	exit $?;;
ps) shift
	[[ -z "$NS" ]] && { NS=$1; shift; }
	[[ -z "$NS" ]] && { Usage >&2; exit 1; }
	ns_pstree $NS
	exit $?;;
del*|del|de|d) switchroot; shift
	[[ -z "$NS" ]] && { NS=$1; shift; }
	[[ -z "$NS" ]] && { Usage >&2; exit 1; }
	systemd-run -M $NS "poweroff"
	ns_pstree $NS | awk 'NF > 4 {print $(NF-3)}' | xargs kill 2>/dev/null
	sleep 1
	ns_pstree $NS | awk 'NF > 4 {print $(NF-3)}' | xargs kill -9 2>/dev/null
	ip link del ve-$NS 2>/dev/null
	macvlan4ns=${NS}.
	for dev in $(ip a s | awk -F'[: @]+' -v pre=${macvlan4ns} '/^[0-9]+:/ {if ($2 ~ "^" pre "[0-9]*$") print $2}'); do
		ip link del "$dev" 2>/dev/null
	done
	[[ $subcmd = delete* ]] && {
		NSdir=$NSHome/$NS
		rm -rf $NSdir
	}
	exit $?;;
ls) shift
	machinectl -l | awk '$2 != "vm" && $2 != "machines"'
	exit $?;;
creat*) shift
	;;
esac

[[ -z "$NS" ]] && { Usage >&2; exit 1; }

switchroot;

NSdir=$NSHome/$NS

#remove existed one
[[ -d $NSdir ]] && {
	echo -e "\n{INFO} remove existed ns and/or rootfs $NSdir ..."
	$0 delete "$NS" 2>/dev/null
}

echo -e "\n{INFO} creating macvlan if for NS ..."
macvlan4ns=${NS}.
loop=0
for addr in $NS_MACVLAN_IPS; do
	is_valid_ip "$addr" || { echo -e "\n{WARN} '$addr' is not a valid address"|grep --color=always . >&2; continue; }
	ifname=${macvlan4ns}$((loop++))
	ip link add link $(getDefaultNic) name ${ifname} type macvlan mode bridge
	#ip link set dev $ifname up
	NET_MACVLAN_OPTS+="--network-macvlan=$ifname "
done

mkdir -p $NSdir
if [[ "$SHARE_SYSTEM" = yes ]]; then
	MachineOpt="-x -D / -M $NS"
else
	echo -e "\n{INFO} creating fs tree for NS $NSdir ..."
	if [[ -n "$CLONE" && -d "$NSHome/$CLONE" ]]; then
		rsync -a --info=progress2 $NSHome/$CLONE/  $NSdir/.
		systemd-machine-id-setup --root $NSdir
	fi
	if rpm --root $NSdir -q $INIT_PKG; then
		systemd-machine-id-setup --root $NSdir
	else
		chroot_install $NSdir $INIT_PKG $PKGS
		\cp -rf /etc/yum.repos.d $NSdir/etc/.
		\cp /etc/{passwd,group,shadow,resolv.conf} $NSdir/etc/.
	fi
	MachineOpt="-D $NSdir"
fi

NETWORK_VETH_OPT=
[[ -n "$HOST_VETH_IP" && -n "$NS_VETH_IP" ]] && NETWORK_VETH_OPT=--network-veth

CMD="systemd-nspawn $BIND_OPTS $VOLATILE_OPT $NETWORK_VETH_OPT $NET_MACVLAN_OPTS $BOOT_OPT $MachineOpt"
echo -e "\n{INFO} [creating NS $NS]: $CMD"
if [[ "$DEBUG" = yes ]]; then
	$CMD
else
	tmux new -s $NS -d "$CMD"
fi

echo -e "\n{INFO} waiting NS $NSdir start ..."
sleep 1
for ((i=0; i<4; i++)); do InitPid=$(ns_init_pid $NSdir) && break; sleep 1; done
[[ -z "$InitPid" ]] && {
	$CMD
	echo -e "\n{Error} something is wrong, exit ."
	$0 del "$NS" 2>/dev/null
	exit 1
}

echo -e "\n{INFO} NS info"
machinectl -l
ns_pstree $NS

# post setup
macvlan4host=macvlan-host
hostvethif=ve-$NS
if [[ -n "$HOST_VETH_IP" && -n "$NS_VETH_IP" ]]; then
	is_valid_ip $HOST_VETH_IP || { HOST_VETH_IP=; echo -e "\n{WARN} '$HOST_VETH_IP' is not a valid address"|grep --color=always . >&2; }
	is_valid_ip $NS_VETH_IP || { NS_VETH_IP=; echo -e "\n{WARN} '$NS_VETH_IP' is not a valid address"|grep --color=always . >&2; }

	echo -e "\n{INFO} setup veth host side $hostvethif $HOST_VETH_IP"
	ip addr add $HOST_VETH_IP/24 dev $hostvethif
	ip link set dev $hostvethif up
	ip a s $hostvethif

	vifidx=$(ip a s $hostvethif|sed -nr -e '/.*@if([0-9]+): .*/{s//\1/;p}')
	nsvethif=$(_nsexec "$InitPid" ip a s | awk -F[@:\ ]+ '/^'$vifidx':/{print $2}')
	echo -e "\n{INFO} setup veth ns side $nsvethif $NS_VETH_IP"
	_nsexec "$InitPid" ip addr add $NS_VETH_IP/24 dev $nsvethif
	_nsexec "$InitPid" ip link set dev $nsvethif up
	_nsexec "$InitPid" ip a s $nsvethif

	#add default route
	_nsexec "$InitPid" ip route add default via $HOST_VETH_IP dev $nsvethif
	_nsexec "$InitPid" sysctl -w net.ipv4.conf.all.rp_filter=2

	#enable NAT
	sysctl -w net.ipv4.conf.all.forwarding=1
	#iptables -A POSTROUTING -s ${HOST_VETH_IP%.*}.0/24 -j MASQUERADE -t nat
	systemctl start firewalld
	firewall-cmd --permanent --zone=public --add-masquerade
	firewall-cmd --reload
else
	:
fi

echo -e "\n{INFO} => setup macvlan ns side:"
loop=0
for addr in $NS_MACVLAN_IPS; do
	is_valid_ip "$addr" || { echo -e "\n{WARN} '$addr' is not a valid address"|grep --color=always . >&2; continue; }
	nsifname=mv-${macvlan4ns}$((loop++))
	echo -e "\n{INFO} setup macvlan if $nsifname $addr"
	_nsexec "$InitPid" ip link set dev $nsifname up
	_nsexec "$InitPid" ip addr add $addr/24 dev $nsifname
	_nsexec "$InitPid" ip a s $nsifname
done

HOST_MACVLAN_IP=192.168.254.254
echo -e "\n{INFO} setup default macvlan host side $macvlan4host $HOST_MACVLAN_IP"
ip link show $macvlan4host &>/dev/null ||
	ip link add link $(getDefaultNic) name $macvlan4host type macvlan mode bridge
ip addr add $HOST_MACVLAN_IP/24 dev $macvlan4host
ip link set dev $macvlan4host up
ip a s $macvlan4host

[[ -n "$HOST_VETH_IP" && -n "$NS_VETH_IP" ]] && {
	echo -e "\n{INFO} ping veth nic $NS_VETH_IP ($hostvethif -> $nsvethif)"
	ping -c 2 $NS_VETH_IP
}
